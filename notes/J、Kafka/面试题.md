1、如何获取 topic 主题的列表

2、生产者和消费者的命令行是什么？

3、consumer 是推还是拉？

4、讲讲 kafka 维护消费状态跟踪的方法

5、讲一下主从同步

6、为什么需要消息系统，mysql 不能满足需求吗？

7、Zookeeper 对于 Kafka 的作用是什么？

8、数据传输的事务定义有哪三种？

9、Kafka 判断一个节点是否还活着有那两个条件？

10、Kafka 与传统 MQ 消息系统之间有三个关键区别

11、讲一讲 kafka 的 ack 的三种机制
12、消费者如何不自动提交偏移量，由应用提交？
13、消费者故障，出现活锁问题如何解决？

14、如何控制消费的位置

15、kafka 分布式（不是单机）的情况下，如何保证消息的顺序消费?

16、kafka 的高可用机制是什么？

17、kafka 如何减少数据丢失

18、kafka 如何不消费重复数据？比如扣款，我们不能重复的扣。

19、kafka特性

20、解决kafka消息丢失问题？



4、讲讲 kafka 维护消费状态跟踪的方法

Topic 被分成了若干分区，每个分区在同一时间只被一个 consumer 消费。这意味着每个分区被消费的消息在日志中的位置仅仅是一个简单的整数：offset。这样就很容易标记每个分区消费状态就很容易了，仅仅需要一个整数而已。这样消费状态的跟踪就很简单了。

这带来了另外一个好处：consumer 可以把 offset 调成一个较老的值，去重新消费老的消息。这对传统的消息系统来说看起来有些不可思议，但确实是非常有用的

6、为什么需要消息系统，mysql 不能满足需求吗？

**（1）解耦：**

允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。

**（2）冗余：**

消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。许多消息队列所采用的”插入-获取-删除”范式中，在把一个消息从队列中删除之前，需要你的处理系统明确的指出该消息已经被处理完毕，从而确保你的数据被安全的保存直到你使用完毕。

**（3）扩展性：**

因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的，只要另外增加处理过程即可。

**（4）灵活性 & 峰值处理能力：**

在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见。如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。

**（5）可恢复性：**

系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。

**（6）顺序保证：**

在大多使用场景下，数据处理的顺序都很重要。大部分消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。（Kafka 保证一个 Partition 内的消息的有序性）

**（7）缓冲：**

有助于控制和优化数据流经过系统的速度，解决生产消息和消费消息的处理速度不一致的情况。

**（8）异步通信：**

很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。

7、Zookeeper 对于 Kafka 的作用是什么？

Zookeeper 是一个开放源码的、高性能的协调服务，它用于 Kafka 的分布式应用。

Zookeeper 主要用于在集群中不同节点之间进行通信

在 Kafka 中，它被用于提交偏移量，因此如果节点在任何情况下都失败了，它都可以从之前提交的偏移量中获取除此之外，它还执行其他活动，如: leader 检测、分布式同步、配置管理、识别新节点何时离开或连接、集群、节点实时状态等等。

19、kafka特性

1. 消息持久化
2. 高吞吐量
3. 扩展性
4. 多客户端支持
5. Kafka Streams
6. 安全机制
7. 数据备份
8. 轻量级
9. 消息压缩

20、解决kafka消息丢失问题？

​	不要使用 producer.send(msg)，而要使用 producer.send(msg, callback)。

​	设置 acks = all。

​	设置 retries 为一个较大的值。

​	设置 unclean.leader.election.enable = false。

​	设置 replication.factor >= 3。

​	设置 min.insync.replicas > 1。如果生产者acks=all，而在发送消息时，Broker的ISR数量没有达到n，Broker不能处理这条消息，需要直接给生产者报错。

​	确保 replication.factor > min.insync.replicas。

​	确保消息消费完成再提交。
