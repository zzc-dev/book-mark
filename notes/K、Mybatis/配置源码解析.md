https://my.oschina.net/xianggao/blog/548896

# 一、各个类的解析源码

四大Builder：

1. **XMLConfigBuilder**

   解析mybatis中configLocation属性中的全局xml文件，内部会使用 `XMLMapperBuilder` 解析各个xml文件。

2. **XMLMapperBuilder**

   遍历mybatis中mapperLocations属性中的xml文件中每个节点的Builder，比如user.xml，内部会使用 `XMLStatementBuilder` 处理xml中的每个节点。

3. **XMLStatementBuilder**

   解析xml文件中各个节点，比如select,insert,update,delete节点，内部会使用 `XMLScriptBuilder` 处理节点的sql部分，遍历产生的数据会丢到Configuration的mappedStatements中。

4. **XMLScriptBuilder**

   解析xml中各个节点sql部分的Builder。

```java
SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
```

## 1.1 SqlSessionFactoryBuilder

```java
public class SqlSessionFactoryBuilder {

    //Reader读取mybatis配置文件，传入构造方法
    //除了Reader外，其实还有对应的inputStream作为参数的构造方法，
    //这也体现了mybatis配置的灵活性
    public SqlSessionFactory build(Reader reader) {
        return build(reader, null, null);
    }

    public SqlSessionFactory build(Reader reader, String environment) {
        return build(reader, environment, null);
    }
  
    //mybatis配置文件 + properties, 此时mybatis配置文件中可以不配置properties，也能使用${}形式
    public SqlSessionFactory build(Reader reader, Properties properties) {
        return build(reader, null, properties);
    }
  
    //通过XMLConfigBuilder解析mybatis配置，然后创建SqlSessionFactory对象
    public SqlSessionFactory build(Reader reader, String environment, Properties properties) {
        try {
            XMLConfigBuilder parser = new XMLConfigBuilder(reader, environment, properties);
            //下面看看这个方法的源码
            return build(parser.parse());
        } catch (Exception e) {
            throw ExceptionFactory.wrapException("Error building SqlSession.", e);
        } finally {
            ErrorContext.instance().reset();
            try {
                reader.close();
            } catch (IOException e) {
                // Intentionally ignore. Prefer previous error.
            }
        }
    }
    
    public SqlSessionFactory build(Configuration config) {
        return new DefaultSqlSessionFactory(config);
    }
}
```



## 1.2 XMLConfigBuilder

> 解析全局配置文件

### 1.2.1 构造函数

```java
    public XMLConfigBuilder(InputStream inputStream, String environment, Properties props) {
        this(new XPathParser(inputStream, true, props, new XMLMapperEntityResolver()), environment, props);
    }

    private XMLConfigBuilder(XPathParser parser, String environment, Properties props) {
        super(new Configuration());
        ErrorContext.instance().resource("SQL Mapper Configuration");
        this.configuration.setVariables(props); // 1.java初始化Builder传递的配置
        this.parsed = false;
        this.environment = environment;
        this.parser = parser;
    }
```

### 1.2.2 parse

1. configuration节点为根节点。

2. 在configuration节点之下，我们可以配置10个子节点，

```java
 //外部调用此方法对mybatis配置文件进行解析
    public Configuration parse() {
        if (parsed) {
            throw new BuilderException("Each XMLConfigBuilder can only be used once.");
        }
        parsed = true;
        //从根节点configuration
        parseConfiguration(parser.evalNode("/configuration"));
        return configuration;
    }

    //此方法就是解析configuration节点下的子节点
    //由此也可看出，我们在configuration下面能配置的节点为以下10个节点
    private void parseConfiguration(XNode root) {
        try {
            propertiesElement(root.evalNode("properties")); //issue #117 read properties first
            typeAliasesElement(root.evalNode("typeAliases"));
            pluginElement(root.evalNode("plugins"));
            objectFactoryElement(root.evalNode("objectFactory"));
            objectWrapperFactoryElement(root.evalNode("objectWrapperFactory"));
            settingsElement(root.evalNode("settings"));
            environmentsElement(root.evalNode("environments"));
            databaseIdProviderElement(root.evalNode("databaseIdProvider"));
            typeHandlerElement(root.evalNode("typeHandlers"));
            mapperElement(root.evalNode("mappers"));
        } catch (Exception e) {
            throw new BuilderException("Error parsing SQL Mapper Configuration. Cause: " + e, e);
        }
    }
```

### 1.2.3 propertiesElement

**配置**

```xml
    <!-- 方法一： 从外部指定properties配置文件, 除了使用resource属性指定外，还可通过url属性指定url  
        <properties resource="dbConfig.properties"></properties> 
    -->
    <!-- 方法二： 直接配置为xml -->
    <properties>
        <property name="driver" value="com.mysql.jdbc.Driver"/>
        <property name="url" value="jdbc:mysql://localhost:3306/test1"/>
        <property name="username" value="root"/>
        <property name="password" value="root"/>
    </properties>
```

​		[方法三](###1.2.1 构造函数)

  <strong style="color:red">**优先级：java代码Porperties对象 > 外部指定配置 >  xml配置**</strong>

```java
	private void propertiesElement(XNode context) throws Exception {
        if (context != null) {
            // 方法二
            Properties defaults = context.getChildrenAsProperties();
            // 获取properties节点上 resource属性的值
            String resource = context.getStringAttribute("resource");
            // 获取properties节点上 url属性的值, resource和url不能同时配置
            String url = context.getStringAttribute("url");
            if (resource != null && url != null) {
                throw new BuilderException("The properties element cannot specify both a URL and a resource based property file 					reference.  Please specify one or the other.");
            }
            // 把解析出的properties文件set进Properties对象
            if (resource != null) {
                defaults.putAll(Resources.getResourceAsProperties(resource));
            } else if (url != null) {
                defaults.putAll(Resources.getUrlAsProperties(url));
            }
            // 将configuration对象中已配置的Properties属性与刚刚解析的融合
            // configuration这个对象会装载所解析mybatis配置文件的所有节点元素，以后也会频频提到这个对象
            // 既然configuration对象用有一系列的get/set方法， 那是否就标志着我们可以使用java代码直接配置？ 
            // 答案是肯定的， 不过使用配置文件进行配置，优势不言而喻
            Properties vars = configuration.getVariables();  // 1. 得到构建sqlSessionFactoryBuilder传递的properties参数
            if (vars != null) {
                defaults.putAll(vars);
            }
            // 把装有解析配置propertis对象set进解析器， 因为后面可能会用到
            parser.setVariables(defaults);
            // set进configuration对象
            configuration.setVariables(defaults);
        }
    }
```

### 1.2.4 environmentsElement

```xml
<environments default="development">
    <environment id="development">
        <!-- 
        JDBC–这个配置直接简单使用了JDBC的提交和回滚设置。它依赖于从数据源得到的连接来管理事务范围。
        MANAGED–这个配置几乎没做什么。它从来不提交或回滚一个连接。而它会让容器来管理事务的整个生命周期（比如Spring或JEE应用服务器的上下文）。
        -->
        <transactionManager type="JDBC"/>
        <!--
        UNPOOLED–这个数据源的实现是每次被请求时简单打开和关闭连接
        POOLED–mybatis实现的简单的数据库连接池类型，它使得数据库连接可被复用，不必在每次请求时都去创建一个物理的连接。
        JNDI – 通过jndi从tomcat之类的容器里获取数据源。
        -->
        <dataSource type="POOLED">  
            <!-- 上面指定了数据库配置文件， 配置文件里面也是对应的这四个属性 -->
            <property name="driver" value="${driver}"/>
            <property name="url" value="${url}"/>
            <property name="username" value="${username}"/>
            <property name="password" value="${password}"/>  
        </dataSource>
    </environment>
    
    <!-- 我再指定一个environment -->
    <environment id="test">
        ...
    </environment>
</environments>
```

1. 根据default得到运行的环境
2. 配置事务  **mybatis有两种：JDBC 和 MANAGED, 配置为JDBC则直接使用JDBC的事务，配置为MANAGED则是将事务托管给容器，** 
3. 得到DataSource
4. 将environment配置加入configuration

```java
    private void environmentsElement(XNode context) throws Exception {
        if (context != null) {
            if (environment == null) {
                //解析environments节点的default属性的值
                //例如: <environments default="development">
                environment = context.getStringAttribute("default");
            }
            //递归解析environments子节点
            for (XNode child : context.getChildren()) { 
                String id = child.getStringAttribute("id");
                //isSpecial就是根据由environments的default属性去选择对应的enviroment
                if (isSpecifiedEnvironment(id)) {
                    //事务， mybatis有两种：JDBC 和 MANAGED, 配置为JDBC则直接使用JDBC的事务，配置为MANAGED则是将事务托管给容器， 
                    TransactionFactory txFactory = transactionManagerElement(child.evalNode("transactionManager"));
                    //enviroment节点下面就是dataSource节点了，解析dataSource节点（下面会贴出解析dataSource的具体方法）
                    DataSourceFactory dsFactory = dataSourceElement(child.evalNode("dataSource"));
                    DataSource dataSource = dsFactory.getDataSource();
                    Environment.Builder environmentBuilder = new Environment.Builder(id)
                          .transactionFactory(txFactory)
                          .dataSource(dataSource);
                    //老规矩，会将dataSource设置进configuration对象
                    configuration.setEnvironment(environmentBuilder.build());
                }
            }
        }
    }
```

#### 1.2.4.1 dataSourceElement 解析dataSource

```java
    private DataSourceFactory dataSourceElement(XNode context) throws Exception {
        if (context != null) {
            //dataSource的连接池
            String type = context.getStringAttribute("type");
            //子节点 name, value属性set进一个properties对象
            Properties props = context.getChildrenAsProperties();
            //创建dataSourceFactory
            DataSourceFactory factory = (DataSourceFactory) resolveClass(type).newInstance();
            factory.setProperties(props);
            return factory;
        }
        throw new BuilderException("Environment declaration requires a DataSourceFactory.");
    } 
```

### 1.2.5 typeAliasesElement

```xml
  	<typeAliases>
        <!--
        通过package, 可以直接指定package的名字， mybatis会自动扫描你指定包下面的javabean,
        并且默认设置一个别名，默认的名字为： javabean 的首字母小写的非限定类名来作为它的别名。
        也可在javabean 加上注解@Alias 来自定义别名， 例如： @Alias(user) 
        <package name="com.dy.entity"/>
        -->
        <typeAlias alias="UserEntity" type="com.dy.entity.User"/>
    </typeAliases>
```



```java
private void typeAliasesElement(XNode parent) {
    if (parent != null) {
        for (XNode child : parent.getChildren()) {
            //如果子节点是package, 那么就获取package节点的name属性， mybatis会扫描指定的package
            if ("package".equals(child.getName())) {
                String typeAliasPackage = child.getStringAttribute("name");
                //TypeAliasRegistry 负责管理别名， 这儿就是通过TypeAliasRegistry 进行别名注册， 下面就会看看TypeAliasRegistry源码
                configuration.getTypeAliasRegistry().registerAliases(typeAliasPackage);
            } else {
                //如果子节点是typeAlias节点，那么就获取alias属性和type的属性值
                String alias = child.getStringAttribute("alias");
                String type = child.getStringAttribute("type");
                try {
                    Class<?> clazz = Resources.classForName(type);
                    if (alias == null) {
                        typeAliasRegistry.registerAlias(clazz);
                    } else {
                        typeAliasRegistry.registerAlias(alias, clazz);
                    }
                } catch (ClassNotFoundException e) {
                    throw new BuilderException("Error registering typeAlias for '" + alias + "'. Cause: " + e, e);
                }
            }
        }
    }
}
```

### 1.2.6 typeHandlerElement 

```xml
 <typeHandlers>
      <!-- 
          当配置package的时候，mybatis会去配置的package扫描TypeHandler
          <package name="com.dy.demo"/>
       -->
      <typeHandler javaType="" jdbcType="" handler=""/>
      
  </typeHandlers>
```

该方法就是通过解析javaType、jdbcType、TypeHandler放到typeHandlerRegistry的map中

```java
private void typeHandlerElement(XNode parent) throws Exception {
    if (parent != null) {
      for (XNode child : parent.getChildren()) {
        //子节点为package时，获取其name属性的值，然后自动扫描package下的自定义typeHandler
        if ("package".equals(child.getName())) {
          String typeHandlerPackage = child.getStringAttribute("name");
          typeHandlerRegistry.register(typeHandlerPackage);
        } else {
          String javaTypeName = child.getStringAttribute("javaType");
          String jdbcTypeName = child.getStringAttribute("jdbcType");
          //handler就是我们配置的typeHandler
          String handlerTypeName = child.getStringAttribute("handler");
          //resolveClass方法就是我们上篇文章所讲的TypeAliasRegistry里面处理别名的方法
          Class<?> javaTypeClass = resolveClass(javaTypeName);
          //JdbcType是一个枚举类型，resolveJdbcType方法是在获取枚举类型的值
          JdbcType jdbcType = resolveJdbcType(jdbcTypeName);
          Class<?> typeHandlerClass = resolveClass(handlerTypeName);
          //注册typeHandler, typeHandler通过TypeHandlerRegistry这个类管理
          if (javaTypeClass != null) {
            if (jdbcType == null) {
              typeHandlerRegistry.register(javaTypeClass, typeHandlerClass);
            } else {
              typeHandlerRegistry.register(javaTypeClass, jdbcType, typeHandlerClass);
            }
          } else {
            typeHandlerRegistry.register(typeHandlerClass);
          }
        }
      }
    }
}
```

### 1.2.7 objectFactoryElement

`MyBatis 每次创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来完成`。`默认的对象工厂需要做的仅仅是实例化目标类，要么通过默认构造方法，要么在参数映射存在的时候通过参数构造方法来实例化`。

自定义ObjectFactory

```xml
<objectFactory type="org.mybatis.example.ExampleObjectFactory">
        <property name="someProperty" value="100"/>
</objectFactory>
```

```java
private void objectFactoryElement(XNode context) throws Exception {
  if (context != null) {
    String type = context.getStringAttribute("type");
    Properties properties = context.getChildrenAsProperties();
    ObjectFactory factory = (ObjectFactory) resolveClass(type).newInstance();
    factory.setProperties(properties);
    configuration.setObjectFactory(factory);
  }
}
```

### 1.2.8 pluginElement

plugins 是一个可选配置。`mybatis中的plugin其实就是个interceptor`， 它可以拦截Executor 、ParameterHandler 、ResultSetHandler 、StatementHandler 的部分方法，处理我们自己的逻辑。

- `Executor` 就是真正执行sql语句的东西，
- ` ParameterHandler` 使用`TypeHandler`处理传入参数
- `ResultSetHandler` 就是处理返回结果的

```xml
    <plugins>
      <plugin interceptor="org.mybatis.example.ExamplePlugin">
        <property name="someProperty" value="100"/>
      </plugin>
    </plugins>
```



```java
  private void pluginElement(XNode parent) throws Exception {
    if (parent != null) {
      for (XNode child : parent.getChildren()) {
        String interceptor = child.getStringAttribute("interceptor");
        Properties properties = child.getChildrenAsProperties();
        Interceptor interceptorInstance = (Interceptor) resolveClass(interceptor).newInstance();
        interceptorInstance.setProperties(properties);
        configuration.addInterceptor(interceptorInstance);
      }
    }
  }
```

### 1.2.9 mapperElement

```xml
    <mappers>
        <!-- 第一种方式：通过resource指定 -->
        <mapper resource="com/dy/dao/userDao.xml"/>
    
        <!-- 第二种方式， 通过class指定接口，进而将接口与对应的xml文件形成映射关系
             不过，使用这种方式必须保证 接口与mapper文件同名(不区分大小写)， 
             我这儿接口是UserDao,那么意味着mapper文件为UserDao.xml 
        <mapper class="com.dy.dao.UserDao"/>
        -->
      
        <!-- 第三种方式，直接指定包，自动扫描，与方法二同理 
        <package name="com.dy.dao"/>
        -->
        <!-- 第四种方式：通过url指定mapper文件位置
        <mapper url="file://........"/>
        -->
    </mappers>
```

`所谓的mapper映射文件，就是让mybatis 用来建立数据表和javabean映射的一个桥梁`。

在我们实际开发中，`通常一个mapper文件对应一个dao接口， 这个mapper可以看做是dao的实现`。所以,mappers必须配置。

### 1.2.10 settingsElement

```xml
<settings> 
    <setting name="cacheEnabled" value="true"/> 
    <setting name="lazyLoadingEnabled" value="true"/> 
    <setting name="multipleResultSetsEnabled" value="true"/> 
    <setting name="useColumnLabel" value="true"/> 
    <setting name="useGeneratedKeys" value="false"/> 
    <setting name="enhancementEnabled" value="false"/> 
    <setting name="defaultExecutorType" value="SIMPLE"/> 
    <setting name="defaultStatementTimeout" value="25000"/> 
</settings>
```

setting节点里配置的值会直接改写Configuration对应的变量值，这些变量描述的是Mybatis的全局运行方式

```java
  private void settingsElement(Properties props) throws Exception {
    configuration.setAutoMappingBehavior(AutoMappingBehavior.valueOf(props.getProperty("autoMappingBehavior", "PARTIAL")));
    configuration.setAutoMappingUnknownColumnBehavior(AutoMappingUnknownColumnBehavior.valueOf(props.getProperty("autoMappingUnknownColumnBehavior", "NONE")));
    configuration.setCacheEnabled(booleanValueOf(props.getProperty("cacheEnabled"), true));
    configuration.setProxyFactory((ProxyFactory) createInstance(props.getProperty("proxyFactory")));
	...
  }
```

<img src="E:\workspace\github\book-mark\images\mybatis01.png" alt="è¾å¥å¾çè¯´æ" style="zoom:50%;" />

## 1.3 TypeAliasRegistry

### 1.3.1 成员变量 TYPE_ALIASES 

```java
  //这就是核心所在啊， 原来别名就仅仅通过一个HashMap来实现， key为别名， value就是别名对应的类型（class对象）
  private final Map<String, Class<?>> TYPE_ALIASES = new HashMap<String, Class<?>>();
```

### 1.3.2 构造器

```java
  /**
   * 以下就是mybatis默认为我们注册的别名
   */
  public TypeAliasRegistry() {
    registerAlias("string", String.class);

    registerAlias("byte", Byte.class);
    registerAlias("long", Long.class);
    registerAlias("short", Short.class);
    registerAlias("int", Integer.class);
    registerAlias("integer", Integer.class);
    registerAlias("double", Double.class);
    registerAlias("float", Float.class);
    registerAlias("boolean", Boolean.class);
    ....
  }
```

### 1.3.3 registerAliases(String packageName)

```java
  /**
   * 配置文件中配置为package的时候， 会调用此方法，根据配置的报名去扫描javabean ，然后自动注册别名
   * 默认会使用 Bean 的首字母小写的非限定类名来作为它的别名
   * 也可在javabean 加上注解@Alias 来自定义别名， 例如： @Alias(user)
   */
  public void registerAliases(String packageName){
    registerAliases(packageName, Object.class);
  }

  public void registerAliases(String packageName, Class<?> superType){
    ResolverUtil<Class<?>> resolverUtil = new ResolverUtil<Class<?>>();
    resolverUtil.find(new ResolverUtil.IsA(superType), packageName);
    Set<Class<? extends Class<?>>> typeSet = resolverUtil.getClasses();
    for(Class<?> type : typeSet){
      // Ignore inner classes and interfaces (including package-info.java)
      // Skip also inner classes. See issue #6
      if (!type.isAnonymousClass() && !type.isInterface() && !type.isMemberClass()) {
        registerAlias(type);
      }
    }
  }
```

### 1.3.4 registerAlias

```java
  public void registerAlias(Class<?> type) {
    String alias = type.getSimpleName();
    Alias aliasAnnotation = type.getAnnotation(Alias.class);
    if (aliasAnnotation != null) {
      alias = aliasAnnotation.value();
    } 
    registerAlias(alias, type);
  }

  //这就是注册别名的本质方法， 其实就是向保存别名的hashMap新增值而已， 呵呵， 别名的实现太简单了，对吧
  public void registerAlias(String alias, Class<?> value) {
    if (alias == null) throw new TypeException("The parameter alias cannot be null");
    String key = alias.toLowerCase(Locale.ENGLISH); // issue #748
    if (TYPE_ALIASES.containsKey(key) && TYPE_ALIASES.get(key) != null && !TYPE_ALIASES.get(key).equals(value)) {
      throw new TypeException("The alias '" + alias + "' is already mapped to the value '" + TYPE_ALIASES.get(key).getName() + "'.");
    }
    TYPE_ALIASES.put(key, value);
  }
```

## 1.4 TypeHandler

> 实现Java类型跟数据库类型的相互转换。

```java
public interface TypeHandler<T> {  
   
	// 用于定义在Mybatis设置参数时该如何把Java类型的参数转换为对应的数据库类型 
    void setParameter(PreparedStatement ps, int i, T parameter,  
           JdbcType jdbcType) throws SQLException;  
   
    // 用于在Mybatis获取数据结果集时如何把数据库类型转换为对应的Java类型  
    T getResult(ResultSet rs, String columnName) throws SQLException;  
   
    // 用于在Mybatis通过字段位置获取字段数据时把数据库类型转换为对应的Java类型  
    T getResult(ResultSet rs, int columnIndex) throws SQLException;  
   
    // 用于Mybatis在调用存储过程后把数据库类型的数据转换为对应的Java类型   
    T getResult(CallableStatement cs, int columnIndex) throws SQLException;  
   
}  
```

### 1.4.1 自定义TypeHandler

User.String[]  <->  varchar 

**实现typeHandler接口**

```java
public class StringArrayTypeHandler implements TypeHandler<String[]> {  
   
       public String[] getResult(ResultSet rs, String columnName)  
                     throws SQLException {  
              String columnValue = rs.getString(columnName);  
              return this.getStringArray(columnValue);  
       }  
   
       public String[] getResult(ResultSet rs, int columnIndex)  
                     throws SQLException {  
              String columnValue = rs.getString(columnIndex);  
              return this.getStringArray(columnValue);  
       }  
   
       public String[] getResult(CallableStatement cs, int columnIndex)  
                     throws SQLException {  
              // TODO Auto-generated method stub  
              String columnValue = cs.getString(columnIndex);  
              return this.getStringArray(columnValue);  
       }  
   
       public void setParameter(PreparedStatement ps, int i, String[] parameter,  
                     JdbcType jdbcType) throws SQLException {  
              if (parameter == null)  
                     ps.setNull(i, Types.VARCHAR);  
              else {  
                     StringBuffer result = new StringBuffer();  
                     for (String value : parameter)  
                            result.append(value).append(",");  
                     result.deleteCharAt(result.length()-1);  
                     ps.setString(i, result.toString());  
              }  
       }  
   
       private String[] getStringArray(String columnValue) {  
              if (columnValue == null)  
                     return null;  
              return columnValue.split(",");  
       }  
   
}  
```

**继承BaseTypeHandler**

```java
public abstract class BaseTypeHandler<T> extends TypeReference<T> implements TypeHandler<T> {  
```

`BaseTypeHandler` 对 `TypeHandler` 接口的四个方法做了一个简单的选择，把null值的情况都做了一个过滤，核心的取值和设值的方法还是抽象出来了供子类来实现。

通过 `TypeReference.getRawType()` 可以获取到当前TypeHandler所使用泛型的原始类型

```java
public class StringArrayTypeHandler extends BaseTypeHandler<String[]> {  
   
    @Override  
    public String[] getNullableResult(ResultSet rs, String columnName)  
           throws SQLException {  
       return getStringArray(rs.getString(columnName));  
    }  
   
    @Override  
    public String[] getNullableResult(ResultSet rs, int columnIndex)  
           throws SQLException {  
       return this.getStringArray(rs.getString(columnIndex));  
    }  
   
    @Override  
    public String[] getNullableResult(CallableStatement cs, int columnIndex)  
           throws SQLException {  
       return this.getStringArray(cs.getString(columnIndex));  
    }  
   
    @Override  
    public void setNonNullParameter(PreparedStatement ps, int i,  
           String[] parameter, JdbcType jdbcType) throws SQLException {  
       //由于BaseTypeHandler中已经把parameter为null的情况做了处理，所以这里我们就不用再判断parameter是否为空了，直接用就可以了  
       StringBuffer result = new StringBuffer();  
       for (String value : parameter)  
           result.append(value).append(",");  
       result.deleteCharAt(result.length()-1);  
       ps.setString(i, result.toString());  
    }  
     
    private String[] getStringArray(String columnValue) {  
       if (columnValue == null)  
           return null;  
       return columnValue.split(",");  
    }  
}  
```

### 1.4.2 注册TypeHandler

<javaType, jdbcType>   →   TypeHandler

1. 指定 <javaType, jdbcType>   →   TypeHandler
2. 指定`javaType`
   - @MappedJdbcTypes({JdbcType.VARCHAR})        <javaType, jdbcType>   →   TypeHandler
   - 没有使用@MappedJdbcTypes                                 <javaType, null>   →   TypeHandler
3. (javaType==null && jdbcType==null)  || jdbcType != null
   - 使用@MappedTypes指定了javaType，goto【方式2】
   - `TypeHandler`没有使用@MappedTypes，但继承了``TypeReference`,使用`TypeReference.getRawType`获取javaType，goto【方式2】
   -  <null, null>   →   TypeHandler

### 1.4.3 Mybatis自动获取TypeHandler

UserMapper.xml

```xml
<?xml version="1.0" encoding="UTF-8" ?>  
<!DOCTYPE mapper  
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"  
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">  
   
<mapper namespace="com.tiantian.mybatis.mapper.UserMapper">  
   
    <resultMap id="UserResult" type="User">  
       <id column="id" property="id"/>  
       <result column="interests" property="interests" javaType="[Ljava.lang.String;" jdbcType="VARCHAR"/>  
    </resultMap>  
   
    <insert id="insertUser" parameterType="User" useGeneratedKeys="true" keyColumn="id">  
       insert into t_user(name, age, interests) values(#{name}, #{age}, #{interests, javaType=[Ljava.lang.String;, jdbcType=VARCHAR})  
    </insert>  
     
    <update id="updateUser" parameterType="User">  
       update t_user set name=#{name}, age=#{age}, interests=#{interests} where id=#{id}  
    </update>  
     
    <select id="findById" parameterType="int" resultMap="UserResult">  
       select * from t_user where id=#{id}  
    </select>  
     
    <delete id="deleteUser" parameterType="int">  
       delete from t_user where id=#{id}  
    </delete>  
</mapper>  
```

1. 在resultMap中，指定了javaType和jdbcType去获取对应的TypeHandler
2. 只指定javaType，<javaType, null>  → TypeHandler

```xml
<result column="interests" property="interests" javaType="[Ljava.lang.String;"/> 
```

 	3. 只指定jdbcType，mybatis会根据`property`指定的java属性获取javaType，  <javaType, jdbcType>  → TypeHandler

```xml
<result column="interests" property="interests" jdbcType="VARCHAR"/> 
```

4. 直接使用typeHandler指定

```xml
 <result column="interests" property="interests" typeHandler="com.tiantian.mybatis.handler.StringArrayTypeHandler"/>  
```

## 1.5 XMLMapperBuilder

Mapper配置文件是由XMLMapperBuilder解析的

- cacheElement
- cacheRefElement
- resultMapElement
- sqlElement

### 1.5.1 cacheElement

二级缓存

步骤：

	1. `XMLMapperBuilder` 解析mapper.xml中的cache标签，调用`cacheElement`
 	2. 在`cacheElement`中将解析好的Cache标签映射到`MapperBuilderAssistant` 的`currentCache` 属性中
 	3. `XMLMapperBuilder` 使用 `XMLStatementBuilder` 解析mapper.xml的update、insert等节点
 	4. 在解析过程中2中的`MapperBuilderAssistant` 的`currentCache` 注入到`MappedStatement` 的cache属性中
 	5. `最终遍历CRUD节点的时候将这个cache节点设置到这些CRUD节点中`，这个cache就是所谓的二级缓存！

```xml
eviction
    LRU – 最近最少使用的:移除最长时间不被使用的对象。

    FIFO – 先进先出:按对象进入缓存的顺序来移除它们。

    SOFT – 软引用:移除基于垃圾回收器状态和软引用规则的对象。

    WEAK – 弱引用:更积极地移除基于垃圾收集器状态和弱引用规则的对象。   
<cache type="PERPETUAL" eviction="LRU" flushInterval="60000"
           size="512" readOnly="true" />
```



```java
private void cacheElement(XNode context) throws Exception {
   if (context != null) {
     String type = context.getStringAttribute("type", "PERPETUAL");
     Class<? extends Cache> typeClass = typeAliasRegistry.resolveAlias(type);
     String eviction = context.getStringAttribute("eviction", "LRU");
     Class<? extends Cache> evictionClass = typeAliasRegistry.resolveAlias(eviction);
     Long flushInterval = context.getLongAttribute("flushInterval");
     Integer size = context.getIntAttribute("size");
     boolean readWrite = !context.getBooleanAttribute("readOnly", false);
     Properties props = context.getChildrenAsProperties();
     builderAssistant.useNewCache(typeClass, evictionClass, flushInterval, size, readWrite, props);
   }
}
```

builderAssistant.useNewCache

> builderAssistant是一个MapperBuilderAssistant类型的帮助类，每个XMLMappedBuilder构造的时候都会实例化这个属性，`MapperBuilderAssistant类内部有个Cache类型的currentCache属性`，这个属性也就是mapper配置文件中 cache节点所代表的值：

`<cache>`被解析到了XMLMapperBuilder.builderAssistant.currentCache

```java
public Cache useNewCache(Class<? extends Cache> typeClass,
    Class<? extends Cache> evictionClass,
    Long flushInterval,
    Integer size,
    boolean readWrite,
    Properties props) {
        typeClass = valueOrDefault(typeClass, PerpetualCache.class);
        evictionClass = valueOrDefault(evictionClass, LruCache.class);
        Cache cache = new CacheBuilder(currentNamespace)
           .implementation(typeClass)
           .addDecorator(evictionClass)
           .clearInterval(flushInterval)
           .size(size)
           .readWrite(readWrite)
           .properties(props)
           .build();
   configuration.addCache(cache);
   currentCache = cache;
   return cache;
}
```

接下来XMLMapperBuilder会解析select节点，解析select节点的时候使用XMLStatementBuilder进行解析(也包括其他insert，update，delete节点)：

```java
public void parseStatementNode() {
   // 解析一些标签的属性
   ....
   builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,
       fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,
       resultSetTypeEnum, flushCache, useCache, resultOrdered,
       keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets);
}
```

builderAssistant.addMappedStatement

```java
public MappedStatement addMappedStatement(...) {

  if (unresolvedCacheRef) {
    throw new IncompleteElementException("Cache-ref not yet resolved");
  }

  id = applyCurrentNamespace(id, false);
  boolean isSelect = sqlCommandType == SqlCommandType.SELECT;

  MappedStatement.Builder statementBuilder = new MappedStatement.Builder(configuration, id, sqlSource, sqlCommandType)
       ...
      .useCache(valueOrDefault(useCache, isSelect))
      .cache(currentCache);

  ParameterMap statementParameterMap = getStatementParameterMap(parameterMap, parameterType, id);
  if (statementParameterMap != null) {
    statementBuilder.parameterMap(statementParameterMap);
  }

  MappedStatement statement = statementBuilder.build();
  configuration.addMappedStatement(statement);
  return statement;
}
```

# 二、parser.parse()详解

[构建SqlSessionFactoryBuilder](# 一、SqlSessionFactoryBuilder) 

​		解析mybaits配置文件

​			 [解析<properties>](##2.3 propertiesElement 解析properties)

​			 [解析<environments>](##2.4 environmentsElement 解析environments)

​			 [解析<typeAliases>](##2.5 typeAliasesElement 自定义别名)

​			 [解析<typeHandler>](##2.6 typeHandlerElement )

​			 [解析<objectFactory>](##2.7 objectFactoryElement)

​			 解析<mappers>

# 三、动态SQL

```xml
<if test="id != null">
     id=#{id}
</if>

<where>
    <if test="id != null">
         id=#{id}
    </if> 
    and deleteFlag=0;
</where>

<!-- 当WHERE后紧随AND或则OR的时候，就去除AND或者O -->
<trim prefix="WHERE" prefixOverrides="AND |OR ">
    ... 
</trim>

<!-- set最后去除逗号 -->
<set>
      <if test="name != null">name = #{name},</if> 
      <if test="password != null">password = #{password},</if> 
      <if test="age != null">age = #{age},</if> 
</set>

<foreach item="item" index="index" collection="list"
    open="(" separator="," close=")">
    #{item}
</foreach>

<choose>
        <when test="title != null">
            AND title like #{title}
        </when>
        <when test="author != null and author.name != null">
            AND author_name like #{author.name}
        </when>
        <otherwise>
            AND featured = 1
        </otherwise>
</choose>
```

## 3.1. 关于动态SQL的接口和类

### 3.1.1 SqlNode

   xml中的每个标签，比如上述sql的update,trim,if标签：

<img src="E:\workspace\github\book-mark\images\mybatis02.png" alt="è¾å¥å¾çè¯´æ" style="zoom: 50%;" />

### 3.1.2 SqlSource

​	代表从xml文件或注解映射的sql内容，主要就是用于创建BoundSql

​	`BoundSql类`，封装mybatis最终产生sql的类，包括sql语句，参数，参数源数据等参数

![è¾å¥å¾çè¯´æ](E:\workspace\github\book-mark\images\mybatis03.png)

## 3.2. 解析动态sql过程

1. XMLConfigBuilder解析mapper.xml

   ```java
   mapperElement(root.evalNode("mappers"));
   
   // mapperElement方法
   XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());
   mapperParser.parse();
   ```

2. XMLMapperBuilder 解析<mapper>

   ```java
   public void parse() {
   	...
       configurationElement(parser.evalNode("/mapper"));
       ...
   }
   
     private void configurationElement(XNode context) {
       try {
         String namespace = context.getStringAttribute("namespace");
         if (namespace == null || namespace.equals("")) {
           throw new BuilderException("Mapper's namespace cannot be empty");
         }
         builderAssistant.setCurrentNamespace(namespace);
         cacheRefElement(context.evalNode("cache-ref"));
         cacheElement(context.evalNode("cache"));
         parameterMapElement(context.evalNodes("/mapper/parameterMap"));
         resultMapElements(context.evalNodes("/mapper/resultMap"));
         sqlElement(context.evalNodes("/mapper/sql"));
         //解析动态sql
         buildStatementFromContext(context.evalNodes("select|insert|update|delete"));
       } catch (Exception e) {
         throw new BuilderException("Error parsing Mapper XML. Cause: " + e, e);
       }
     }
   
     private void buildStatementFromContext(List<XNode> list, String requiredDatabaseId) {
       for (XNode context : list) {
           // 使用XMLStatementBuilder
         final XMLStatementBuilder statementParser = new XMLStatementBuilder(configuration, builderAssistant, context, requiredDatabaseId);
         try {
           statementParser.parseStatementNode();
         } catch (IncompleteElementException e) {
           configuration.addIncompleteStatement(statementParser);
         }
       }
     }
   ```

3. XMLStatementBuilder 解析每个节点CRUD

   ```java
   public void parseStatementNode() {
       ...
   	LanguageDriver langDriver = this.getLanguageDriver(lang);
       ...
   	SqlSource sqlSource = langDriver.createSqlSource(this.configuration, this.context, parameterTypeClass);
       ...
   }
   ```

4. LanguageDriver解析SQL，得到SqlSource

   ```java
   @Override
   public SqlSource createSqlSource(Configuration configuration, XNode script, Class<?> parameterType) {
     XMLScriptBuilder builder = new XMLScriptBuilder(configuration, script, parameterType);
     return builder.parseScriptNode();
   }
   ```

5. XMLScriptBuilder 解析SQL

   > 得到SqlSource之后，会放到Configuration中，有了SqlSource，就能拿BoundSql了，BoundSql可以得到最终的sql。

   ```java
   public SqlSource parseScriptNode() {
       List<SqlNode> contents = this.parseDynamicTags(this.context);
       MixedSqlNode rootSqlNode = new MixedSqlNode(contents);
       SqlSource sqlSource = null;
       if (this.isDynamic) {
           sqlSource = new DynamicSqlSource(this.configuration, rootSqlNode);
       } else {
           sqlSource = new RawSqlSource(this.configuration, rootSqlNode, this.parameterType);
       }
   
       return (SqlSource)sqlSource;
   }
   ```

## 3.3 parseDynamicTags

```xml
<update id="update" parameterType="org.format.dynamicproxy.mybatis.bean.User">
    UPDATE users
    <trim prefix="SET" prefixOverrides=",">
        <if test="name != null and name != ''">
            name = #{name}
        </if>
        <if test="age != null and age != ''">
            , age = #{age}
        </if>
        <if test="birthday != null and birthday != ''">
            , birthday = #{birthday}
        </if>
    </trim>
    where id = ${id}
</update>
```

1. 首先根据update节点(Node)得到所有的子节点，分别是3个子节点：
   - 文本节点 \n UPDATE users
   - trim子节点 ...
   - 文本节点 \n where id = #{id}

2. 遍历各个子节点：

   2.1 `如果节点类型是文本或者CDATA`，构造一个TextSqlNode或StaticTextSqlNode；

   2.2 `如果节点类型是元素，说明该update节点是个动态sql`，然后会使用NodeHandler处理各个类型的子节点。这里的NodeHandler是XMLScriptBuilder的一个内部接口，其实现类包括TrimHandler、WhereHandler、SetHandler、IfHandler、ChooseHandler等。看类名也就明白了这个Handler的作用，比如我们分析的trim节点，对应的是TrimHandler；if节点，对应的是IfHandler...这里子节点trim被TrimHandler处理，TrimHandler内部也使用parseDynamicTags方法解析节点。

3. 遇到子节点是元素的话，重复以上步骤

# 四、通过JDK动态代理来包装SqlSession 源码分析

https://blog.csdn.net/zcw4237256/article/details/79032351

# 五、SQL执行流程

```java
SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
SqlSession sqlSession = sessionFactory.openSession();
// 使用sqlSession执行sql
ObjectMapper mapper = sqlSession.getMapper("");
```

## 5.1 通过XMLConfigBuilder解析配置文件

解析配置文件并保存在Configuration对象中，返回DefaultSqlSesionFactory对象

![image-20210710144415525](E:\workspace\github\book-mark\images\mybatis12.png)

## 5.2 创建SqlSession

![image-20210710145348600](E:\workspace\github\book-mark\images\mybatis13.png)

```java
 private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) {
   Transaction tx = null;
   try {
     //通过Confuguration对象去获取Mybatis相关配置信息, Environment对象包含了数据源和事务的配置
     final Environment environment = configuration.getEnvironment();
     final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);
     tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);
     //之前说了，从表面上来看，咱们是用sqlSession在执行sql语句， 实际呢，其实是通过excutor执行， excutor是对于Statement的封装
     final Executor executor = configuration.newExecutor(tx, execType);
     //关键看这儿，创建了一个DefaultSqlSession对象
     return new DefaultSqlSession(configuration, executor, autoCommit);
   } catch (Exception e) {
     closeTransaction(tx); // may have fetched a connection so lets call close()
     throw ExceptionFactory.wrapException("Error opening session.  Cause: " + e, e);
   } finally {
     ErrorContext.instance().reset();
   }
 }
```

1. 从配置中获取Environment；
2. 从Environment中取得DataSource；
3. 从Environment中取得TransactionFactory；
4. 从DataSource里获取数据库连接对象Connection；
5. 在取得的数据库连接上创建事务对象Transaction；
6. 创建Executor对象（该对象非常重要，事实上sqlsession的所有操作都是通过它完成的）；
7. 创建sqlsession对象。

## 5.3 jdk动态代理获取mapper代理对象MapperProxy

![image-20210710145841587](E:\workspace\github\book-mark\images\mybatis14.png)

## 5.4 执行sql

![image-20210710151631897](E:\workspace\github\book-mark\images\mybatis15.png)

![image-20210710151813497](E:\workspace\github\book-mark\images\mybatis16.png)

![image-20210710151933753](E:\workspace\github\book-mark\images\mybatis17.png)	

### 5.4.1 MapperProxy.invoke ->

```java
  @Override
  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    if (Object.class.equals(method.getDeclaringClass())) {
      try {
        return method.invoke(this, args);
      } catch (Throwable t) {
        throw ExceptionUtil.unwrapThrowable(t);
      }
    }
    final MapperMethod mapperMethod = cachedMapperMethod(method);
    //二话不说，主要交给MapperMethod自己去管
    return mapperMethod.execute(sqlSession, args);
  }
```

### 5.4.2 mapperMethod.execute ->

```java
  /**
   * 其实就是先判断CRUD类型，然后根据类型去选择到底执行sqlSession中的哪个方法，
   */
  public Object execute(SqlSession sqlSession, Object[] args) {
    Object result;
    if (SqlCommandType.INSERT == command.getType()) {
      Object param = method.convertArgsToSqlCommandParam(args);
      result = rowCountResult(sqlSession.insert(command.getName(), param));
    } 
    ...
    return result;
  }
```

### 5.4.3 sqlSession.selectList ->

```java
  public <E> List<E> selectList(String statement, Object parameter, RowBounds rowBounds) {
    try {
      MappedStatement ms = configuration.getMappedStatement(statement);
      //CRUD实际上是交给Excetor去处理， excutor其实也只是穿了个马甲而已，小样，别以为穿个马甲我就不认识你嘞！
      return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);
    } catch (Exception e) {
      throw ExceptionFactory.wrapException("Error querying database.  Cause: " + e, e);
    } finally {
      ErrorContext.instance().reset();
    }
  }
```

### 5.4.4 Excutor.query

#### 5.4.4.1 Excutor实例化

**Sqlsession只是个门面，真正干事的是Executor，Sqlsession对数据库的操作都是通过Executor来完成的**

`Executor对象是可以被插件拦截的，如果定义了针对Executor类型的插件，最终生成的Executor对象是被各个插件插入后的代理对象`。

```java
    public Executor newExecutor(Transaction transaction, ExecutorType executorType) {  
  
        executorType = executorType == null ? defaultExecutorType : executorType;  
  
        executorType = executorType == null ?ExecutorType.SIMPLE : executorType;  
  
        Executor executor;  
  
        if(ExecutorType.BATCH == executorType) {
            executor = new BatchExecutor(this,transaction);
        } else if(ExecutorType.REUSE == executorType) {
            executor = new ReuseExecutor(this,transaction);  
        } else {  
            executor = new SimpleExecutor(this, transaction);
        }
  
        if (cacheEnabled) {
           executor = new CachingExecutor(executor);  
        }
        executor = (Executor) interceptorChain.pluginAll(executor);  
        return executor;  
    }  
```

- `BatchExecutor  `专门用于执行批量sql操作
- `ReuseExecutor` 会重用statement执行sql操作
- `SimpleExecutor` 只是简单执行sql没有什么特别的，**默认**

>`CachingExecutor` 在查询数据库前先查找缓存，若没找到的话调用delegate（就是构造时传入的Executor对象）从数据库查询，并将查询结果存入缓存中
>
>**默认开启缓存**

#### 5.4.4.2 query

```java
public List query(MappedStatement ms, Object parameterObject, RowBounds rowBounds,ResultHandler resultHandler) throws SQLException {  
    if (ms != null) {  
        Cache cache = ms.getCache();  
        if (cache != null) {  
            flushCacheIfRequired(ms);  
            cache.getReadWriteLock().readLock().lock();  
            try {  
                if (ms.isUseCache() && resultHandler ==null) {  
                    CacheKey key = createCacheKey(ms, parameterObject, rowBounds);  
                    final List cachedList = (List)cache.getObject(key);  
                    if (cachedList != null) {  
                        return cachedList;  
                    } else {  
                        List list = delegate.query(ms,parameterObject, rowBounds, resultHandler);  
                        tcm.putObject(cache,key, list);  
                        return list;  
                    }  
                } else {  
                    return delegate.query(ms,parameterObject, rowBounds, resultHandler);  
                }  
            } finally {  
                cache.getReadWriteLock().readLock().unlock();  
            }
        }  
    }  
    return delegate.query(ms,parameterObject, rowBounds, resultHandler);  
}
```

最终调用到StatementHandler处理sql

```java
  public <E> List<E> doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException {
    Statement stmt = null;
    try {
      Configuration configuration = ms.getConfiguration();
      StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);
      stmt = prepareStatement(handler, ms.getStatementLog());
      //StatementHandler封装了Statement, 让 StatementHandler 去处理
      return handler.<E>query(stmt, resultHandler);
    } finally {
      closeStatement(stmt);
    }
  }
```

# 六、缓存源码

## 6.1 一级缓存

`SqlSession`使用`Executor` 完成会话操作

先关闭二级缓存

```xml
<setting name="cacheEnabled" value="false"/>
```

###  6.1.1 SqlSession.selectOne  → SqlSession.selectList → Executor.query

Executor.query 实际上是`BaseExecutor`.query

​		[Executor实例化](####4.4.1 Excutor实例化)

 localCache就是一级缓存

  第一次查询key1时，localCache.getObject(key)返回null，`queryFromDatabase`查询到结果并保存到localCache中 `localCache.putObject(key, list);`第二次查询key1，localCache.getObject(key) 直接返回结果

```java
protected PerpetualCache localCache;

public <E> List<E> query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws 				SQLException {
    BoundSql boundSql = ms.getBoundSql(parameter);
    CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);
    return query(ms, parameter, rowBounds, resultHandler, key, boundSql);
 }

@Override
  public <E> List<E> query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key,      BoundSql boundSql) throws SQLException {
    ErrorContext.instance().resource(ms.getResource()).activity("executing a query").object(ms.getId());
    if (closed) {
      throw new ExecutorException("Executor was closed.");
    }
    if (queryStack == 0 && ms.isFlushCacheRequired()) {
      clearLocalCache();
    }
    List<E> list;
    try {
      queryStack++;
      // 根据key读取缓存
      list = resultHandler == null ? (List<E>) localCache.getObject(key) : null;
      if (list != null) {
        handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);
      } else {
        list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);
      }
    } finally {
      queryStack--;
    }
    if (queryStack == 0) {
      for (DeferredLoad deferredLoad : deferredLoads) {
        deferredLoad.load();
      }
      // issue #601
      deferredLoads.clear();
      if (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) {
        // issue #482
        clearLocalCache();
      }
    }
    return list;
  }

  private <E> List<E> queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, 		CacheKey key, BoundSql boundSql) throws SQLException {
    List<E> list;
    localCache.putObject(key, EXECUTION_PLACEHOLDER);
    try {
      list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);
    } finally {
      localCache.removeObject(key);
    }
    localCache.putObject(key, list);
    if (ms.getStatementType() == StatementType.CALLABLE) {
      localOutputParameterCache.putObject(key, parameter);
    }
    return list;
  }

public class PerpetualCache implements Cache {
    private String id;
    private Map<Object, Object> cache = new HashMap();
```

### 6.1.2 insert | update | delete

update和delete最终都会到达BaseExcutor的update方法，可以看出每次执行真正的update操作之前， 先把本地缓存localCache清空，

因此**执行新增或更新或删除操作，缓存被清空**

```java
  @Override
  public int update(MappedStatement ms, Object parameter) throws SQLException {
    ErrorContext.instance().resource(ms.getResource()).activity("executing an update").object(ms.getId());
    if (closed) {
      throw new ExecutorException("Executor was closed.");
    }
    clearLocalCache();
    return doUpdate(ms, parameter);
  }

  @Override
  public void clearLocalCache() {
    if (!closed) {
      localCache.clear();
      localOutputParameterCache.clear();
    }
  }
```

### 6.1.3 commit

提交事务也会将localCache清空

```java
@Override
public void commit(boolean required) throws SQLException {
  if (closed) {
    throw new ExecutorException("Cannot commit, transaction is already closed");
  }
  clearLocalCache();
  flushStatements();
  if (required) {
    transaction.commit();
  }
}
```

## 6.2 二级缓存

**二级缓存的作用域是全局的，二级缓存在SqlSession关闭或提交之后才会生效**

![输入图片说明](E:\workspace\github\book-mark\images\mybatis05.png)

### 6.2.1 缓存配置

1. mybatis全局配置文件中的setting中的cacheEnabled需要为true(默认为true，不设置也行)
2. mapper配置文件中需要加入<cache>节点
3. mapper配置文件中的select节点需要加上属性useCache需要为true(默认为true，不设置也行)

### 6.2.2 cache如何绑定到CRUD节点 

[<cache>绑定节点](###5.1 cacheElement)

### 6.2.3 cache查询流程

```
查询数据的话，先从二级缓存中拿数据，如果没有的话，去一级缓存中拿，一级缓存也没有的话再查询数据库`。有了数据之后在`丢到TransactionalCache这个对象的entriesToAddOnCommit属性中
```

 开启了二级缓存，则Executor是CachingExcutor

​			[Executor实例化](####4.4.1 Excutor实例化)

#### 6.2.3.1 TransactionalCacheManager

 成员变量`transactionalCaches` 每个mapper.xml文件都有自己的cache，存储者全局二级缓存

`TransactionalCache` 存储着当前cache的缓存，以节点的namespace+id为key

```java
Map<Cache, TransactionalCache> transactionalCaches = new HashMap<Cache, TransactionalCache>();
```

```java
class TransactionalCache{
    private Map<Object, Object> entriesToAddOnCommit;
}
```

#### 6.2.3.2 查询流程

**CachingExcutor.query** ->

```java
public <E> List<E> query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)
     throws SQLException {
   Cache cache = ms.getCache();
   if (cache != null) {
     flushCacheIfRequired(ms);
     if (ms.isUseCache() && resultHandler == null) {
       ensureNoOutParams(ms, parameterObject, boundSql);
       @SuppressWarnings("unchecked")
       List<E> list = (List<E>) tcm.getObject(cache, key);
       if (list == null) {
         list = delegate.<E> query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
         tcm.putObject(cache, key, list); // issue #578. Query must be not synchronized to prevent deadlocks
       }
       return list;
     }
   }
   return delegate.<E> query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
}
```

TransactionalCacheManager.putObject、getObject

```java
  public Object getObject(Cache cache, CacheKey key) {
    return getTransactionalCache(cache).getObject(key);
  }

public void putObject(Cache cache, CacheKey key, Object value) {
   getTransactionalCache(cache).putObject(key, value);
}

private TransactionalCache getTransactionalCache(Cache cache) {
   TransactionalCache txCache = transactionalCaches.get(cache);
   if (txCache == null) {
     txCache = new TransactionalCache(cache);
     transactionalCaches.put(cache, txCache);
   }
   return txCache;
}
```

 TransactionalCache的putObject方法：

```java
private Map<Object, AddEntry> entriesToAddOnCommit;

public void putObject(Object key, Object object) {
   entriesToRemoveOnCommit.remove(key);
   entriesToAddOnCommit.put(key, new AddEntry(delegate, key, object));
}

private static class AddEntry {
   private Cache cache;
   private Object key;
   private Object value;

   public AddEntry(Cache cache, Object key, Object value) {
     this.cache = cache;
     this.key = key;
     this.value = value;
   }

   public void commit() {
     cache.putObject(key, value);
   }
}
```

#### 6.2.3.3 二级缓存为什么commit后才能生效

AddEntry的commit方法会把数据丢到cache中，也就是丢到二级缓存中

关于为何调用close方法后，二级缓存才会生效，`因为close方法内部会调用commit方法`



1. DefaultSqlSession.commit()  ➡

2. CachingExecutor.commit()

   ```java
   public void commit(boolean required) throws SQLException {
      delegate.commit(required);
      tcm.commit();
      dirty = false;
   }
   ```

3.  tcm.commit();

   ```
   public void commit() {
      for (TransactionalCache txCache : transactionalCaches.values()) {
        txCache.commit();
      }
   }
   ```

4. TransactionalCache.commit()

   ```java
   public void commit() {
      delegate.getReadWriteLock().writeLock().lock();
      try {
        if (clearOnCommit) {
          delegate.clear();
        } else {
          for (RemoveEntry entry : entriesToRemoveOnCommit.values()) {
            entry.commit();
          }
        }
        for (AddEntry entry : entriesToAddOnCommit.values()) {
          entry.commit();
        }
        reset();
      } finally {
        delegate.getReadWriteLock().writeLock().unlock();
      }
   }
   
   // AddEntry
   public void commit() {
       cache.putObject(key, value);
   }
   ```

#  七、插件原理

![image-20210710152505692](E:\workspace\github\book-mark\images\mybatis18.png)

MyBatis提供了一种插件(plugin)的功能，虽然叫做插件，但其实这是拦截器功能。

**MyBatis 允许你在已映射语句执行过程中的某一点进行拦截调用**。

1. Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed) 拦截执行器的方法

2. ParameterHandler (getParameterObject, setParameters) 拦截参数的处理

3. ResultSetHandler (handleResultSets, handleOutputParameters) 拦截结果集的处理

4. StatementHandler (prepare, parameterize, batch, update, query) 拦截Sql语法构建的处理

   

Mybatis采用**责任链模式**，通过**动态代理**组织多个拦截器（插件），通过这些拦截器可以改变Mybatis的默认行为（诸如SQL重写之类的），



**在编写插件时需注意以下几个原则：**

1. 不编写不必要的插件；
2. 实现plugin方法时判断一下目标类型，是本插件要拦截的对象才执行Plugin.wrap方法，否者直接返回目标本省，这样可以减少目标被代理的次数。

## 7.1 拦截器的使用

- intercept

  `实现拦截逻辑的地方`，`内部要通过invocation.proceed()显式地推进责任链前进`，也就是调用下一个拦截器拦截目标方法

- plugin

  `用当前这个拦截器生成对目标target的代理`，实际是通过Plugin.wrap(target,this)来完成的，把目标target和拦截器this传给了包装函数。

- setProperties

  设置额外的参数`，参数配置在`拦截器的Properties节点里

**定义自己的Interceptor最重要的是要实现plugin方法和intercept方法，**

​	**在plugin方法中我们可以决定是否要进行拦截进而决定要返回一个什么样的目标对象。**

​	**而intercept方法就是要进行拦截的时候要执行的方法。**

```java
public interface Interceptor {

  Object intercept(Invocation invocation) throws Throwable;

  Object plugin(Object target);

  void setProperties(Properties properties);

}
```

实现：

```java
// 当前插件要拦截哪个对象的哪个方法
@Intercepts({@Signature(type= Executor.class, method = "update", args = {MappedStatement.class,Object.class})})
public class ExamplePlugin implements Interceptor {
  public Object intercept(Invocation invocation) throws Throwable {
    return invocation.proceed();
  }
  public Object plugin(Object target) {
    return Plugin.wrap(target, this);
  }
  public void setProperties(Properties properties) {
  }
}
```

```xml
<plugins>
    <plugin interceptor="org.format.mybatis.cache.interceptor.ExamplePlugin">
    	<property name="name" value="zzc"/>
    </plugin>
</plugins>
```

**Plugin.wrap**

决定要返回的对象是目标对象还是对应的代理

```java
 //一个静态方法,对一个目标对象进行包装，生成代理类。
  public static Object wrap(Object target, Interceptor interceptor) {
    //首先根据interceptor上面定义的注解 获取需要拦截的信息
    Map<Class<?>, Set<Method>> signatureMap = getSignatureMap(interceptor);
    //目标对象的Class
    Class<?> type = target.getClass();
    //返回需要拦截的接口信息
    Class<?>[] interfaces = getAllInterfaces(type, signatureMap);
    //如果长度为>0 则返回代理类 否则不做处理
    if (interfaces.length > 0) {
      return Proxy.newProxyInstance(
          type.getClassLoader(),
          interfaces,
          new Plugin(target, interceptor, signatureMap));
    }
    return target;
  }
```



## 7.2 加入拦截器链

```java
private void pluginElement(XNode parent) throws Exception {
    if (parent != null) {
        for (XNode child : parent.getChildren()) {
            String interceptor = child.getStringAttribute("interceptor");
            Properties properties = child.getChildrenAsProperties();
            Interceptor interceptorInstance = (Interceptor) resolveClass(interceptor).newInstance();
            interceptorInstance.setProperties(properties);
            configuration.addInterceptor(interceptorInstance);
        }
    }
}

public void addInterceptor(Interceptor interceptor) {
    interceptorChain.addInterceptor(interceptor);
}
```

`interceptorChain `是 `Configuration` 的内部属性

```java
public class InterceptorChain {

    private final List<Interceptor> interceptors = new ArrayList<Interceptor>();

    public Object pluginAll(Object target) {
        for (Interceptor interceptor : interceptors) {
            target = interceptor.plugin(target);
        }
        return target;
    }

    public void addInterceptor(Interceptor interceptor) {
        interceptors.add(interceptor);
    }

    public List<Interceptor> getInterceptors() {
        return Collections.unmodifiableList(interceptors);
    }

}
```

## 7.3 拦截器如何作用

```java
public ParameterHandler newParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql) {
    ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);
    parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);
    return parameterHandler;
}

public ResultSetHandler newResultSetHandler(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler, ResultHandler resultHandler, BoundSql boundSql) {
    ResultSetHandler resultSetHandler = new DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);
    resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);
    return resultSetHandler;
}

public StatementHandler newStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) {
    StatementHandler statementHandler = new RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);
    statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);
    return statementHandler;
}

public Executor newExecutor(Transaction transaction, ExecutorType executorType, boolean autoCommit) {
    executorType = executorType == null ? defaultExecutorType : executorType;
    executorType = executorType == null ? ExecutorType.SIMPLE : executorType;
    Executor executor;
    if (ExecutorType.BATCH == executorType) {
        executor = new BatchExecutor(this, transaction);
    } else if (ExecutorType.REUSE == executorType) {
        executor = new ReuseExecutor(this, transaction);
    } else {
        executor = new SimpleExecutor(this, transaction);
    }
    if (cacheEnabled) {
        executor = new CachingExecutor(executor, autoCommit);
    }
    executor = (Executor) interceptorChain.pluginAll(executor);
    return executor;
}
```

## 7.4 自定义分页插件

PageHelper

https://my.oschina.net/xianggao/blog/550537

Mybatis的分页功能很弱，它是基于内存的分页（`查出所有记录再按偏移量和limit取结果`），`在大数据量的情况下这样的分页基本上是没有用的`。

本文基于插件，通过拦截StatementHandler重写sql语句，`实现数据库的物理分页`。

```java
public Object intercept(Invocation invocation) throws Throwable {  
     StatementHandler statementHandler = (StatementHandler) invocation.getTarget();  
     MetaObject metaStatementHandler = MetaObject.forObject(statementHandler,  
     DEFAULT_OBJECT_FACTORY, DEFAULT_OBJECT_WRAPPER_FACTORY);  
     // 分离代理对象链(由于目标类可能被多个拦截器拦截，从而形成多次代理，通过下面的两次循环  
     // 可以分离出最原始的的目标类)  
     while (metaStatementHandler.hasGetter("h")) {  
         Object object = metaStatementHandler.getValue("h");  
         metaStatementHandler = MetaObject.forObject(object, DEFAULT_OBJECT_FACTORY,   
         DEFAULT_OBJECT_WRAPPER_FACTORY);  
     }  
     // 分离最后一个代理对象的目标类  
     while (metaStatementHandler.hasGetter("target")) {  
         Object object = metaStatementHandler.getValue("target");  
         metaStatementHandler = MetaObject.forObject(object, DEFAULT_OBJECT_FACTORY,   
         DEFAULT_OBJECT_WRAPPER_FACTORY);  
     }  
     Configuration configuration = (Configuration) metaStatementHandler.  
     getValue("delegate.configuration");  
     dialect = configuration.getVariables().getProperty("dialect");  
     if (null == dialect || "".equals(dialect)) {  
         logger.warn("Property dialect is not setted,use default 'mysql' ");  
         dialect = defaultDialect;  
     }  
     pageSqlId = configuration.getVariables().getProperty("pageSqlId");  
     if (null == pageSqlId || "".equals(pageSqlId)) {  
         logger.warn("Property pageSqlId is not setted,use default '.*Page$' ");  
         pageSqlId = defaultPageSqlId;  
     }  
     MappedStatement mappedStatement = (MappedStatement)   
     metaStatementHandler.getValue("delegate.mappedStatement");  
     // 只重写需要分页的sql语句。通过MappedStatement的ID匹配，默认重写以Page结尾的  
     //  MappedStatement的sql  
     if (mappedStatement.getId().matches(pageSqlId)) {  
         BoundSql boundSql = (BoundSql) metaStatementHandler.getValue("delegate.boundSql");  
         Object parameterObject = boundSql.getParameterObject();  
         if (parameterObject == null) {  
             throw new NullPointerException("parameterObject is null!");  
         } else {  
             // 分页参数作为参数对象parameterObject的一个属性  
             PageParameter page = (PageParameter) metaStatementHandler  
                     .getValue("delegate.boundSql.parameterObject.page");  
             String sql = boundSql.getSql();  
             // 重写sql  
             String pageSql = buildPageSql(sql, page);  
             metaStatementHandler.setValue("delegate.boundSql.sql", pageSql);  
             // 采用物理分页后，就不需要mybatis的内存分页了，所以重置下面的两个参数  
             metaStatementHandler.setValue("delegate.rowBounds.offset",   
             RowBounds.NO_ROW_OFFSET);  
             metaStatementHandler.setValue("delegate.rowBounds.limit", RowBounds.NO_ROW_LIMIT);  
             Connection connection = (Connection) invocation.getArgs()[0];  
             // 重设分页参数里的总页数等  
             setPageParameter(sql, connection, mappedStatement, boundSql, page);  
         }  
     }  
     // 将执行权交给下一个拦截器  
     return invocation.proceed();  
}
```
